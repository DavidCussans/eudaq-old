//This is data acquisition part of the vme_test program written by Janusz Mlynarczyk 
//The program is performing SIS ADC data aquisition and it is equivalent to the 
//SIS -> Sample from config of the vme_test with all the required initialisations
//daq_beam use one data file to collect all the events and one stop is one event 
//(daq_beam is working in stop mode)


#include "daq_beam.h"

int main() {
  int dev;  /* device descriptor for VME access returned by open function */
	int returnCode;  
	
	u_int32_t base;  
	u_int32_t baseV1495;  

	time_t tm;  
	char *timenow;

	base = 0x30000000;  //base address for SIS3300 
	baseV1495 = 0x40000000;  //base address for Caen V1495
	
	printf("\n\n");
    //print timestamp 		
	time(&tm); timenow = ctime(&tm);	  
	printf(timenow,"\n"); 	  
	  
	printf("1 -> Openining VME environment: ");
  	if ((dev=open("/tmp/sis1100", O_RDWR, 0))<0) {
  		printf("\nerror on opening VME environment\n\n");  		
  		printf("\ncheck if VME is connected and the proper driver is loaded. Exiting...\n\n");  		     	    
  		return -1;
  	} 
  	else {
  		printf("Opening VME environment: Successful\n"); 
  	}  	
    
  	printf("2 -> Resetting VME bus: ");
  	returnCode = vmesysreset(dev);
    print_return_code(returnCode);
    
    sleep(1);  //otherwise problems with board programming (reset takes some time)
    
    printf("3 -> reading fpga.cfg and programming V1495\n");
    programV1495(dev, baseV1495);
    
    sleep(1);  //otherwise problems with data aquisition (FPGA is not ready immediatly)
    
	printf("4 -> reading adc.cfg and sampling using SIS3300\n");
	Sample(dev, base, baseV1495);	
	
	//closing VME before exit
	printf("5 -> Closing VME environment and exiting\n\n");
	close(dev);
	return 0;
}

void print_return_code (int returnCode) {
	if (returnCode == 0) printf ("Successful   \n");
	if (returnCode != 0) {
		printf ("ERROR   ");
		printf("(returnCode = %d)\n",returnCode);
	}	
}

void programV1495(int dev, u_int32_t baseV1495) { //VME is supposed to be open yet!
		
	u_int32_t address;
	u_int32_t data;	
	u_int16_t data16;
	
	int offset;
	int returnCode;
		
	char line [100];
	int i, ret;
	
	FILE *pConfigFile;	
			
	//open the file
	pConfigFile = fopen ("fpga.cfg","r");
	if (pConfigFile==NULL) 	{
	    	printf("error opening fpga.cfg\n");
	    	return;
	}  
	//read the file until the start pattern found; start pattern is $$
	for (i=0; i<3000; i++) { //surely not more than 3000 words...
		fscanf(pConfigFile, "%s",line);
		if (line[0]=='$' && line[1]=='$') {
			break;
		}
		if (i==2999) {
			printf("\nProblem reading file. Probably the start pattern of $$ was not found\n");  
			return;
		}
	}
	//reading configuration part of the file
	for (i=0; i<500; i++) { //surely not more than 500 lines...

		ret=readCommentLine(pConfigFile); //reading comment line				
		if (ret==-1) return; //problem with the file	
		if (ret==0) break; //end of the file
		
		//reading data	   
		fscanf (pConfigFile,"%x",&offset);    		
		fscanf (pConfigFile,"%x",&data);
		address=baseV1495+offset;    		  
		//printf("VME A32D16 write: offset 0x%X, offset 0x%X,", offset, data); 
		returnCode = vme_A32D16_write(dev,address,data);
		//print_return_code(returnCode); //to see if everythings goes OK
	
	} 

	printf("  Reading programmed data:\n");
	int off;    		 
    for (off=0; off<58; off=off+2) {
   		  vme_A32D16_read(dev,baseV1495+off,&data16);
   		  printf("   offset 0x%X, data 0x%X \n", off, data16);
  	}
	return;
}

void Sample(int dev, u_int32_t base, u_int32_t baseV1495) { //sample acording to the file adc.cfg 
	
	FILE *pConfigFile, *pDataFile, *pInfoFile;	
	int samples;
	int data, channel, memBank, acqRegData, cfgRegData, keyStart, nChannels, iEvent, nEvents, nFiles;
	short int iTriggerLSB, iTriggerMSB;
	int iTrigger; 
	char word[200];
	char channel_string[10];
	char format[2]; //FILE *hFile;should be 2 because 'A' or 'B' + '\0' for end of line
	int i, ix, ret;
	char run_name[4];
	char dataFileName[17]; //name of the file to store the sampled data
	char infoFileName[13]; //name of info file.
	char c;
	unsigned int sampleClock;
	
	//open the adc.cfg file
	pConfigFile = fopen ("adc.cfg","r");	
	if (pConfigFile==NULL)
	{	    
	    printf("error opening the configuration file\n");
	    return;
	}
	
	//read the file until the start pattern found; start pattern is $$
	for (i=0; i<3000; i++) { //surely not more than 3000 words...
		fscanf(pConfigFile, "%s",word); //first word
		if (word[0]=='$' && word[1]=='$') {
			break;
		}
		if (i==2999) {
			printf("\nProblem reading file. Probably the start pattern of $$ was not found\n");  
			return;
		}
	}
	//reading configuration part of the file
			
	ret=readCommentLine(pConfigFile); //reading comment line				
	if (ret==1) fscanf (pConfigFile,"%u",&samples); //reading data (number of samples)
	else return;
			
	readCommentLine(pConfigFile); //reading comment line		
	if (ret==1) fscanf (pConfigFile,"%x",&acqRegData); //read acquisition register setup		
	else return;
		
	readCommentLine(pConfigFile); //reading comment line		
	if (ret==1) fscanf (pConfigFile,"%x",&cfgRegData); //read acquisition register setup
	else return;
		
	readCommentLine(pConfigFile); //reading comment line		
	if (ret==1) fscanf (pConfigFile,"%u",&memBank); //read acquisition register setup
	else return;	 
	readCommentLine(pConfigFile); //reading comment line		
	if (ret==1) fscanf (pConfigFile,"%u",&keyStart); //read acquisition register setup
	else return;
	
	ret=readCommentLine(pConfigFile); //reading comment line				
	if (ret==1) fscanf (pConfigFile,"%s",channel_string); //reading string data for channels
	else return;
	
	ret=readCommentLine(pConfigFile); //reading comment line				
	if (ret==1) fscanf (pConfigFile,"%s",format); //reading format ascii or binary (A or B)
	else return;
	
	ret=readCommentLine(pConfigFile); //reading comment line				
	if (ret==1) fscanf (pConfigFile,"%u",&nEvents); //number of events (reading cycles) per file 
	else return;
	
	ret=readCommentLine(pConfigFile); //reading comment line				
	if (ret==1) fscanf (pConfigFile,"%u",&nFiles); //number of files (for compatibility with daq and vme_test programs)
	else return;
		
	ret=readCommentLine(pConfigFile); //reading comment line				
	if (ret==1) fscanf (pConfigFile,"%s",run_name); //run number (for the file name)
	else return;
	
	//matrixes for ADC data
	unsigned int noOfReadWords;	
	unsigned int rawData12[samples]; //for ADC12 channel group (i.e. channel 1 and channel 2)
	unsigned int rawData34[samples]; //for ADC34 channel group
	unsigned int rawData56[samples]; //for ADC56 channel group
	unsigned int rawData78[samples]; //for ADC78 channel group
	
	nChannels=strlen(channel_string);
	
	//writing info file
	strcpy(infoFileName,"run_"); 
	strcat(infoFileName,run_name);
	strcat(infoFileName,".inf");
	pInfoFile = fopen (infoFileName,"w");	
	if (pInfoFile==NULL)
	{	     
	    printf("error opening the info file for writing\n");
	    return;
	}
	writeInfoFile(pInfoFile, samples, nChannels, nEvents, nFiles, channel_string);
	fclose(pInfoFile);	
		
	//open the data file 
	strcpy(dataFileName,"run_"); 
	strcat(dataFileName,run_name);
	remove(dataFileName); //because it will be open in append mode.
	pDataFile = fopen( dataFileName, "a"); //"w" opens for writing, overwrite existing data ("a" to append existing data)								   
	if (pDataFile == NULL) {  
		printf("\nError opening data file\n");// Error, file not found
		return;
	}                                                                                                             	
		    
	// general board reset
	vme_A32D32_write(dev, base + 0x20, 0x7);

	//reseting the trigger counter on FPGA (iTrigger will be saved in the data file along with iEvent for debugging purpose)
	vme_A32D16_write(dev, base + 0x004A, 0); 
		
	// acquisition register (0x10):
	vme_A32D32_write(dev, base + 0x10, acqRegData); 
	vme_A32D32_read(dev, base + 0x10, &data); 
		
	// event configuration register (0x100000 for ALL_ADC; write only):
	vme_A32D32_write(dev, base + 0x100000, cfgRegData);		
	vme_A32D32_read(dev, base + 0x200000, &data); //read from ADC12   
	printf("  Event config register ADC12 reads:  %x\n", data);
	
	iEvent=1;

	//starting the loop to acquire the required number of events		
	for (ix=0;ix<nEvents;ix++) {  //ix is the local count for the loop only. it is not equal iEvent 
								  //first of all iEvent start from 1 and also it is not reset when the next file starts   

		// arm for sampling memory bank 1 = 0x1, memory bank 2 = 0x2
		vme_A32D32_write(dev, base + 0x10, memBank);
		
		// issue a key start if required by user in the adc.cfg file 
		if (keyStart==1) vme_A32D32_write(dev, base + 0x30, 0x7);
		
		// --------test beam related------------------------//
		//unforce the busy
		vme_A32D16_write(dev, baseV1495 + 0x4C, 0);		
		// --------test beam related------------------------//
		
		// checking Sample Clock Enable status		
		vme_A32D32_read(dev, base + 0x10, &sampleClock);
			
		while ( (sampleClock & 0x1) == 0x1) { //checking it the last bit of the acquisition register is still 1
												  //(remains true untill sampling is finished) 
			vme_A32D32_read(dev, base + 0x10, &sampleClock);			
		}

		//reading all channels data anyway. data to send to file will be selected later
		vme_A32BLT32_read(dev, base + 0x400000, rawData12, (unsigned) samples, &noOfReadWords);
		vme_A32BLT32_read(dev, base + 0x480000, rawData34, (unsigned) samples, &noOfReadWords);
		vme_A32BLT32_read(dev, base + 0x500000, rawData56, (unsigned) samples, &noOfReadWords);
		vme_A32BLT32_read(dev, base + 0x580000, rawData78, (unsigned) samples, &noOfReadWords);
						
		//checking trigger counter from FPGA, added for debuging purpose 
		vme_A32D16_read(dev, baseV1495 + 0x003C, &iTriggerLSB);
		vme_A32D16_read(dev, baseV1495 + 0x003E, &iTriggerMSB);
		iTrigger=(iTriggerMSB<<16)+iTriggerLSB;
		//printf("iTrigger=0x%x iTriggerLSB=0x%x",iTrigger, iTriggerLSB);
				
		//writing header to the data file if binary format was chosen. One header per event
		if (format[0]=='B') header2file(pDataFile, iEvent, iTrigger);
				
		//write data to the file
		for (i=0;i<nChannels;i++) {
			c=channel_string[i];
			channel=c-48; //channel=atoi(&c); //character 2 integer in another way (ATT: atoi() is doing strange things...)				
			if (format[0]=='A') {
				if (channel==1 || channel==2) samples2file(pDataFile, rawData12, channel, samples, iEvent);
				if (channel==3 || channel==4) samples2file(pDataFile, rawData34, channel, samples, iEvent);
				if (channel==5 || channel==6) samples2file(pDataFile, rawData56, channel, samples, iEvent);
				if (channel==7 || channel==8) samples2file(pDataFile, rawData78, channel, samples, iEvent);
			}
			else if (format[0]=='B') {				
				if (channel==1 || channel==2) samples2fileBinary(pDataFile, rawData12, channel, samples, iEvent, iTrigger);
				if (channel==3 || channel==4) samples2fileBinary(pDataFile, rawData34, channel, samples, iEvent, iTrigger);
				if (channel==5 || channel==6) samples2fileBinary(pDataFile, rawData56, channel, samples, iEvent, iTrigger);
				if (channel==7 || channel==8) samples2fileBinary(pDataFile, rawData78, channel, samples, iEvent, iTrigger);
			}
			else printf("\nWrong format definition in the adc.cfg file. Use A for ASCII or B for Binary\n");			
		}	
		//writing trailer to the data file if binary format was chosen. One trailer per event
		if (format[0]=='B') {		
			data=0x89abcdef; 
			fwrite(&data, 4, 1, pDataFile); //writes data in binary format
		}
					
	  	//Resetting VME bus
		//vmesysreset(dev);
		//sleep(1);//usleep(900000);  
	    //reading fpga.cfg and programming V1495
		//programV1495(dev, baseV1495);
	    //sleep(1);//usleep(900000);
		// --------test beam related------------------------//
	    //force the busy
	    vme_A32D16_write(dev, baseV1495 + 0x4C, 1);
	    //reset internal busy
	    vme_A32D16_write(dev, baseV1495 + 0x48, 7); 
		// --------test beam related------------------------//
	    //usleep(100000);	    
	}
	//closing data file
	fclose(pDataFile);
	printf("  Acquired %i events to the data file. iTrigger=%i",nEvents,iTrigger);
	printf("\n\n");
	fclose(pConfigFile);
}

int readCommentLine(FILE *pConfigFile) {
	
	int ret, i;
	char word [100];
	char c1, c2;
	
	ret=fscanf(pConfigFile, "%s", word); //first word
	if (ret<0) { //end of file
		fclose (pConfigFile);	  
		return 0;
	}
	if (word[0]=='/' && word[1]=='*') { //start of comment
		fscanf(pConfigFile, "%c", &c1);//read one by one - first character
		for (i=0; i<500; i++) { //surely not more than 500 characters...
			fscanf(pConfigFile, "%c", &c2);//read next character
			if (c1=='*' && c2=='/') { //end of comment
				break;
			}
			if (i==499) {
				printf("\nProblem with comment line. Too long or missing */ at the end\n");  
				return -1;
			}
			c1=c2; 
		}    					  
	}
	return 1;
}

void samples2file(FILE *hFile, unsigned int *rawData, int channel, int samples, int iEvent) {
	
	int iSample,data;	
	
	switch (channel) {
		case 1:
		case 3:
		case 5:
		case 7:			
			for (iSample = 0; iSample < samples; iSample++) {
				data = ((rawData[iSample] >> 16) & 0xFFFF);		//data in memory from D31-D16
				fprintf(hFile, "%d\t%d\t%d\t%d\n", iEvent, channel, iSample, data); //writes data in decimal format to text file
			}	
		break;		
		
		case 2:
		case 4:
		case 6:
		case 8:
			for (iSample = 0; iSample < samples; iSample++) {
				//data = ((rawData[iSample] >> 0) & 0x0FFF);		//data in memory from D11-D0
				data = ((rawData[iSample] >> 0) & 0xFFFF);		//data in memory from D15-D0
				fprintf(hFile, "%d\t%d\t%d\t%d\n", iEvent, channel, iSample, data); //writes data in decimal format to text file 
			}
		break;
	}
	return;	
}

void samples2fileBinary(FILE *hFile, unsigned int *rawData, int channel, int samples, int iEvent, int iTrigger) {
		
	int iSample,data;	

	//writing data
	int size=2; //size of data to be written, in bytes
	switch (channel) {
		case 1:
		case 3:
		case 5:
		case 7:			
			for (iSample = 0; iSample < samples; iSample++) {
				data = ((rawData[iSample] >> 16) & 0xFFFF);		//data in memory from D31-D16
				fwrite(&data, size, 1, hFile); //writes data in binary format. size if 2 bytes
				//pointer to the array of elements to be written,
				//size in bytes of each element to be written,
				//number of elements, each one with a size of size bytes,
				//pointer to a FILE object that specifies an output stream.
				// to read the file under Linux use: 
				// >od -h sample.dat //for hexadecimal short format (equivalent to >od -t x2 sample.dat)    
				// >od -t x4 -A d -v sample.dat //probably in the final 4 bytes long hexadecimal
			}	
		break;		
		
		case 2:
		case 4:
		case 6:
		case 8:
			for (iSample = 0; iSample < samples; iSample++) {
				//data = ((rawData[iSample] >> 0) & 0x0FFF); 		//data in memory from D11-D0
				data = ((rawData[iSample] >> 0) & 0xFFFF);		//data in memory from D13-D0
				fwrite(&data, size, 1, hFile); //writes data in binary format
			}
		break;
	}

	return;	
}

void header2file(FILE *pDataFile, int iEvent, int iTrigger){ 
		
		int i;
		long int header [28]; //28 long words = 28x4 = 112 bytes
   		
		header [0]=0x0;
		header [1]=iEvent;//event number
		header [2]=iEvent;//event number 
		header [3]=iTrigger; //iTrigger (from FPGA, for debug in future) 
		for (i=0;i<24;i++) {  //remaining fields of the header are 0
			header [4+i] = 0x0;
		}
		//writing header
		for (i=0;i<28;i++) {
			fwrite(&header[i], sizeof(header[i]), 1, pDataFile); //writes data in binary format
		}
}  

void writeInfoFile(FILE *hFile, int samples, int nChannels, int nEvents, int nFiles, char *channel_string) {
	
	int nWords=12;
	long int InfoData[nWords];
	int i, size;
	char c;
	
	InfoData[0]=0x1; //format, for Little Endian (less significant first) = 1 
	InfoData[1]=0x0; InfoData[2]=0x0; //not used
	InfoData[3]=nEvents; //number of events in the file (if file not splited = nEvent)
	InfoData[4]=nEvents*nFiles; //number of events in the run	
	InfoData[5]=28*4 + samples*2*nChannels + 1*4; //single event size in bytes (header, data, trailer)
	InfoData[6]=samples*2*nChannels; //data size in bytes (only data, without header and trailer) 
	InfoData[7]=0x0; InfoData[8]=0x0; InfoData[9]=0x0; InfoData[10]=0x0; //not used
	InfoData[10]=nChannels; //number of channels (number of ADCs)	
	//preparing channel info for InfoData[11]:
	InfoData[11]=0x0; //initialise at 0
	int bit; //bit to be set
	for (i=0;i<nChannels;i++) {
		c=channel_string[i];
		bit=atoi(&c); //bit to be set. character 2 integer on channel number
		InfoData[11] = InfoData[11] | (1 << (bit-1)); //channel 4 => set bit 4, itd,  using OR logical operation		
	}
	
	//writing header
	size=4; //Long words = 4bytes	
	for (i=0;i<nWords;i++) { 
		fwrite(&InfoData[i], size, 1, hFile); //writes data in binary format.
	}	
	return;
}
